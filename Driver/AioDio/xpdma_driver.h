#ifndef XPDMA_DRIVER_H
#define XPDMA_DRIVER_H

#define DEVICE_NAME "xdma_ad"

#define SUCCESS         0
#define CRIT_ERR       -1

/* XDMA registers offsets */
enum {
	/* H2C Channel Registers. Up to 4 channels with 0x100 bytes spacing */
	XDMA_H2C_CHNL_ID = 0x0000,
	XDMA_H2C_CHNL_CTRL = 0x0004,
	XDMA_H2C_CHNL_CTRL_W1S = 0x0008,
	XDMA_H2C_CHNL_CTRL_W1C = 0x000C,
	XDMA_H2C_CHNL_STATUS = 0x0040,
	XDMA_H2C_CHNL_STATUS_RC = 0x0044,
	XDMA_H2C_CHNL_COMPLETED_DESC_COUNT = 0x0048,
	XDMA_H2C_CHNL_ALIGNMENTS = 0x004C,
	XDMA_H2C_CHNL_POLL_LOW_WRITE_BACK_ADDR = 0x0088,
	XDMA_H2C_CHNL_POLL_HIGH_WRITE_BACK_ADDR = 0x008C,
	XDMA_H2C_CHNL_INT_ENABLE_MASK = 0x0090,
	XDMA_H2C_CHNL_INT_ENABLE_MASK_W1S = 0x0094,
	XDMA_H2C_CHNL_INT_ENABLE_MASK_W1C = 0x0098,
	XDMA_H2C_CHNL_PERF_MONITOR_CTRL = 0x00C0,
	XDMA_H2C_CHNL_PERF_CYCLE_COUNT = 0x00C4,
	XDMA_H2C_CHNL_PERF_DATA_COUNT = 0x00CC,

	/* C2H Channel Registers. Up to 4 channels with 0x100 bytes spacing */
	XDMA_C2H_CHNL_ID = 0x1000,
	XDMA_C2H_CHNL_CTRL = 0x1004,
	XDMA_C2H_CHNL_CTRL_W1S = 0x1008,
	XDMA_C2H_CHNL_CTRL_W1C = 0x100C,
	XDMA_C2H_CHNL_STATUS = 0x1040,
	XDMA_C2H_CHNL_STATUS_RC = 0x1044,
	XDMA_C2H_CHNL_COMPLETED_DESC_COUNT = 0x1048,
	XDMA_C2H_CHNL_ALIGNMENTS = 0x104C,
	XDMA_C2H_CHNL_POLL_LOW_WRITE_BACK_ADDR = 0x1088,
	XDMA_C2H_CHNL_POLL_HIGH_WRITE_BACK_ADDR = 0x108C,
	XDMA_C2H_CHNL_INT_ENABLE_MASK = 0x1090,
	XDMA_C2H_CHNL_INT_ENABLE_MASK_W1S = 0x1094,
	XDMA_C2H_CHNL_INT_ENABLE_MASK_W1C = 0x1098,
	XDMA_C2H_CHNL_PERF_MONITOR_CTRL = 0x10C0,
	XDMA_C2H_CHNL_PERF_CYCLE_COUNT = 0x10C4,
	XDMA_C2H_CHNL_PERF_DATA_COUNT = 0x10CC,

	/* IRQ Block Registers */
	XDMA_IRQ_BLK_ID = 0x2000,
	XDMA_IRQ_BLK_USER_INT_EN_MASK = 0x2004,
	XDMA_IRQ_BLK_USER_INT_EN_MASK_W1S = 0x2008,
	XDMA_IRQ_BLK_USER_INT_EN_MASK_W1C = 0x200C,
	XDMA_IRQ_BLK_CHNL_INT_EN_MASK = 0x2010,
	XDMA_IRQ_BLK_CHNL_INT_EN_MASK_W1S = 0x2014,
	XDMA_IRQ_BLK_CHNL_INT_EN_MASK_W1C = 0x2018,
	XDMA_IRQ_USER_INT_REQUEST = 0x2040,
	XDMA_IRQ_BLK_CHNL_INT_REQUEST = 0x2044,
	XDMA_IRQ_BLK_USER_INT_PENDING = 0x2048,
	XDMA_IRQ_BLK_CHNL_INT_PENDING = 0x204C,
	XDMA_IRQ_BLK_USER_VECTOR_1 = 0x2080,
	XDMA_IRQ_BLK_USER_VECTOR_2 = 0x2084,
	XDMA_IRQ_BLK_USER_VECTOR_3 = 0x2088,
	XDMA_IRQ_BLK_USER_VECTOR_4 = 0x208C,
	XDMA_IRQ_BLK_CHNL_VECTOR_1 = 0x20A0,
	XDMA_IRQ_BLK_CHNL_VECTOR_2 = 0x20A4,

	/* Config Block Registers */
	XDMA_CFG_BLK_ID = 0x3000,
	XDMA_CFG_BLK_BUSDEV = 0x3004,
	XDMA_CFG_BLK_PCIE_MAX_PAYLOAD_SIZE = 0x3008,
	XDMA_CFG_BLK_PCIE_MAX_READ_REQUEST_SIZE = 0x300C,
	XDMA_CFG_BLK_SYSTEM_ID = 0x3010,
	XDMA_CFG_BLK_MSI_ENABLE = 0x3014,
	XDMA_CFG_BLK_PCIE_DATA_WIDTH = 0x3018,
	XDMA_CFG_PCIE_CTRL = 0x301C,
	XDMA_CFG_AXI_USER_MAX_PAYLOAD_SIZE = 0x3040,
	XDMA_CFG_AXI_USER_MAX_READ_REQUSEST_SIZE = 0x3044,
	XDMA_CFG_WRITE_FLUSH_TIMEOUT = 0x3060,

	/* H2C SGDMA Registers */
	XDMA_H2C_SGDMA_ID = 0x4000,
	XDMA_H2C_SGDMA_DESC_LOW = 0x4080,
	XDMA_H2C_SGDMA_DESC_HIGH = 0x4084,
	XDMA_H2C_SGDMA_DESC_ADJACENT = 0x4088,

	/* C2H SGDMA Registers */
	XDMA_C2H_SGDMA_ID = 0x5000,
	XDMA_C2H_SGDMA_DESC_LOW = 0x5080,
	XDMA_C2H_SGDMA_DESC_HIGH = 0x5084,
	XDMA_C2H_SGDMA_DESC_ADJACENT = 0x5088,
};

#define BIT_N(n)                            (1 << (n))
#define ADDR_OFFSET(addr, offset)           ((void *)((size_t)(addr) + offset))

#define XDMA_DESC_MAGIC                     0xAD4B0000
#define XDMA_ID_MAGIC                       0x1FC
#define XDMA_WB_MAGIC                       0x52B4

 // bits of the SGDMA descriptor control field
#define XDMA_DESC_STOP_BIT                  (BIT_N(0))
#define XDMA_DESC_COMPLETED_BIT             (BIT_N(1))
#define XDMA_DESC_EOP_BIT                   (BIT_N(4))

 /* H2C/C2H control register bits */
#define XDMA_CTRL_RUN_STOP                  (1 << 0)
#define XDMA_CTRL_IE_DESC_STOPPED           (1 << 1)
#define XDMA_CTRL_IE_DESC_COMPLETED         (1 << 2)
#define XDMA_CTRL_IE_DESC_ALIGN_MISMATCH    (1 << 3)
#define XDMA_CTRL_IE_MAGIC_STOPPED          (1 << 4)
#define XDMA_CTRL_IE_IDLE_STOPPED           (1 << 6)
#define XDMA_CTRL_IE_READ_ERROR             (0x1F << 9)
#define XDMA_CTRL_IE_DESC_ERROR             (0x1F << 19)
#define XDMA_CTRL_NON_INCR_ADDR             (1 << 25)
#define XDMA_CTRL_POLL_MODE_WB              (1 << 26)

 /* DMA status register bits */
#define XDMA_STAT_BUSY                      (1 << 0)
#define XDMA_STAT_DESC_STOPPED              (1 << 1)
#define XDMA_STAT_DESC_COMPLETED            (1 << 2)
#define XDMA_STAT_ALIGN_MISMATCH            (1 << 3)
#define XDMA_STAT_MAGIC_STOPPED             (1 << 4)
#define XDMA_STAT_FETCH_STOPPED             (1 << 5)
#define XDMA_STAT_IDLE_STOPPED              (1 << 6)
#define XDMA_STAT_READ_ERROR                (0x1F << 9)
#define XDMA_STAT_DESC_ERROR                (0x1F << 19)
#define XDMA_RESULT_EOP_BIT                 (BIT_N(0))

// Struct Used for send/receive data
typedef struct {
    uint32_t count;
    uint32_t addr;
} Buffer_t;

#define IOC_MAGIC 0xA5

#endif //XPDMA_DRIVER_H
